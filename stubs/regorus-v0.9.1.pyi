# regorus.pyi
from __future__ import annotations

from typing import Any, Dict, List, Mapping, Optional, Sequence, Tuple, Union

_JSONScalar = Union[str, int, float, bool, None]
_JSONValue = Union[_JSONScalar, List["_JSONValue"], Dict[str, "_JSONValue"]]
_BytesLike = Union[bytes, bytearray, memoryview]

class Engine:
    """
    Regorus Engine (embedded Rego evaluator).

    Notes:
      - Methods raise exceptions on failure (Rust anyhow::Result -> Python exception).
      - Many APIs accept "Rego values" via Python objects: dict/set/frozenset/list/tuple/str/int/float/bool/None.
    """

    def __init__(self) -> None: ...
    def set_rego_v0(self, enable: bool) -> None: ...
    def add_policy(self, path: str, rego: str) -> None: ...
    def add_policy_from_file(self, path: str) -> None: ...
    def get_packages(self) -> List[str]: ...
    def get_policies(self) -> str: ...
    def add_data(self, data: Any) -> None: ...
    def add_data_json(self, data: str) -> None: ...
    def add_data_from_json_file(self, path: str) -> None: ...
    def clear_data(self) -> None: ...
    def set_input(self, input: Any) -> None: ...
    def set_input_json(self, input: str) -> None: ...
    def set_input_from_json_file(self, path: str) -> None: ...
    def eval_query(self, query: str) -> Dict[str, Any]: ...
    def eval_query_as_json(self, query: str) -> str: ...
    def eval_rule(self, rule: str) -> Any: ...
    def eval_rule_as_json(self, rule: str) -> str: ...
    def set_enable_coverage(self, enable: bool) -> None: ...

    # Available only if built with Rust feature "coverage"
    def get_coverage_report_as_json(self) -> str: ...
    def get_coverage_report_pretty(self) -> str: ...
    def clear_coverage_data(self) -> None: ...
    def set_gather_prints(self, b: bool) -> None: ...
    def take_prints(self) -> List[str]: ...

    # Available only if built with Rust feature "ast"
    def get_ast_as_json(self) -> str: ...

class Program:
    """RVM program wrapper."""

    @staticmethod
    def compile_from_modules(
        data_json: str,
        modules: Sequence[Tuple[str, str]],
        entry_points: Sequence[str],
    ) -> Program: ...
    @staticmethod
    def deserialize_binary(data: _BytesLike) -> Tuple[Program, bool]: ...
    def serialize_binary(self) -> bytes: ...
    def generate_listing(self) -> str: ...
    def generate_tabular_listing(self) -> str: ...

class Rvm:
    """RVM runtime wrapper."""

    def __init__(self) -> None: ...
    def load_program(self, program: Program) -> None: ...
    def set_data_json(self, data_json: str) -> None: ...
    def set_input_json(self, input_json: str) -> None: ...
    def set_execution_mode(self, mode: int) -> None: ...
    def execute(self) -> str: ...
    def execute_entry_point(self, entry_point: str) -> str: ...
    def resume(self, resume_json: Optional[str]) -> str: ...
    def get_execution_state(self) -> str: ...
